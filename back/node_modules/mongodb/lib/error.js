"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isResumableError = exports.isNetworkTimeoutError = exports.isSDAMUnrecoverableError = exports.isNodeShuttingDownError = exports.isRetryableError = exports.isRetryableWriteError = exports.MongoWriteConcernError = exports.MongoServerSelectionError = exports.MongoTimeoutError = exports.MongoParseError = exports.MongoNetworkTimeoutError = exports.MongoNetworkError = exports.isNetworkErrorBeforeHandshake = exports.MongoError = exports.GET_MORE_RESUMABLE_CODES = exports.MONGODB_ERROR_CODES = void 0;
const kErrorLabels = Symbol('errorLabels');
/** @internal MongoDB Error Codes */
exports.MONGODB_ERROR_CODES = Object.freeze({
    HostUnreachable: 6,
    HostNotFound: 7,
    NetworkTimeout: 89,
    ShutdownInProgress: 91,
    PrimarySteppedDown: 189,
    ExceededTimeLimit: 262,
    SocketException: 9001,
    NotMaster: 10107,
    InterruptedAtShutdown: 11600,
    InterruptedDueToReplStateChange: 11602,
    NotMasterNoSlaveOk: 13435,
    NotMasterOrSecondary: 13436,
    StaleShardVersion: 63,
    StaleEpoch: 150,
    StaleConfig: 13388,
    RetryChangeStream: 234,
    FailedToSatisfyReadPreference: 133,
    CursorNotFound: 43,
    LegacyNotPrimary: 10058,
    WriteConcernFailed: 64,
    NamespaceNotFound: 26,
    IllegalOperation: 20,
    MaxTimeMSExpired: 50,
    UnknownReplWriteConcern: 79,
    UnsatisfiableWriteConcern: 100
});
// From spec@https://github.com/mongodb/specifications/blob/f93d78191f3db2898a59013a7ed5650352ef6da8/source/change-streams/change-streams.rst#resumable-error
exports.GET_MORE_RESUMABLE_CODES = new Set([
    exports.MONGODB_ERROR_CODES.HostUnreachable,
    exports.MONGODB_ERROR_CODES.HostNotFound,
    exports.MONGODB_ERROR_CODES.NetworkTimeout,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.ExceededTimeLimit,
    exports.MONGODB_ERROR_CODES.SocketException,
    exports.MONGODB_ERROR_CODES.NotMaster,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotMasterNoSlaveOk,
    exports.MONGODB_ERROR_CODES.NotMasterOrSecondary,
    exports.MONGODB_ERROR_CODES.StaleShardVersion,
    exports.MONGODB_ERROR_CODES.StaleEpoch,
    exports.MONGODB_ERROR_CODES.StaleConfig,
    exports.MONGODB_ERROR_CODES.RetryChangeStream,
    exports.MONGODB_ERROR_CODES.FailedToSatisfyReadPreference,
    exports.MONGODB_ERROR_CODES.CursorNotFound
]);
/**
 * @public
 * @category Error
 */
class MongoError extends Error {
    constructor(message) {
        if (message instanceof Error) {
            super(message.message);
            this.stack = message.stack;
        }
        else {
            if (typeof message === 'string') {
                super(message);
            }
            else {
                super(message.message || message.errmsg || message.$err || 'n/a');
                if (message.errorLabels) {
                    this[kErrorLabels] = new Set(message.errorLabels);
                }
                for (const name in message) {
                    if (name === 'errorLabels' || name === 'errmsg') {
                        continue;
                    }
                    this[name] = message[name];
                }
            }
            Error.captureStackTrace(this, this.constructor);
        }
        this.name = 'MongoError';
    }
    /** Legacy name for server error responses */
    get errmsg() {
        return this.message;
    }
    /**
     * Creates a new MongoError object
     *
     * @param options - The options used to create the error.
     * @deprecated Use `new MongoError()` instead.
     */
    static create(options) {
        return new MongoError(options);
    }
    /**
     * Checks the error to see if it has an error label
     *
     * @param label - The error label to check for
     * @returns returns true if the error has the provided error label
     */
    hasErrorLabel(label) {
        if (this[kErrorLabels] == null) {
            return false;
        }
        return this[kErrorLabels].has(label);
    }
    addErrorLabel(label) {
        if (this[kErrorLabels] == null) {
            this[kErrorLabels] = new Set();
        }
        this[kErrorLabels].add(label);
    }
    get errorLabels() {
        return this[kErrorLabels] ? Array.from(this[kErrorLabels]) : [];
    }
}
exports.MongoError = MongoError;
const kBeforeHandshake = Symbol('beforeHandshake');
function isNetworkErrorBeforeHandshake(err) {
    return err[kBeforeHandshake] === true;
}
exports.isNetworkErrorBeforeHandshake = isNetworkErrorBeforeHandshake;
/**
 * An error indicating an issue with the network, including TCP errors and timeouts.
 * @public
 * @category Error
 */
class MongoNetworkError extends MongoError {
    constructor(message, options) {
        super(message);
        this.name = 'MongoNetworkError';
        if (options && options.beforeHandshake === true) {
            this[kBeforeHandshake] = true;
        }
    }
}
exports.MongoNetworkError = MongoNetworkError;
/**
 * An error indicating a network timeout occurred
 * @public
 * @category Error
 */
class MongoNetworkTimeoutError extends MongoNetworkError {
    constructor(message, options) {
        super(message, options);
        this.name = 'MongoNetworkTimeoutError';
    }
}
exports.MongoNetworkTimeoutError = MongoNetworkTimeoutError;
/**
 * An error used when attempting to parse a value (like a connection string)
 * @public
 * @category Error
 */
class MongoParseError extends MongoError {
    constructor(message) {
        super(message);
        this.name = 'MongoParseError';
    }
}
exports.MongoParseError = MongoParseError;
/**
 * An error signifying a client-side timeout event
 * @public
 * @category Error
 */
class MongoTimeoutError extends MongoError {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    constructor(message, reason) {
        if (reason && reason.error) {
            super(reason.error.message || reason.error);
        }
        else {
            super(message);
        }
        this.name = 'MongoTimeoutError';
        if (reason) {
            this.reason = reason;
        }
    }
}
exports.MongoTimeoutError = MongoTimeoutError;
/**
 * An error signifying a client-side server selection error
 * @public
 * @category Error
 */
class MongoServerSelectionError extends MongoTimeoutError {
    constructor(message, reason) {
        super(message, reason);
        this.name = 'MongoServerSelectionError';
    }
}
exports.MongoServerSelectionError = MongoServerSelectionError;
function makeWriteConcernResultObject(input) {
    const output = Object.assign({}, input);
    if (output.ok === 0) {
        output.ok = 1;
        delete output.errmsg;
        delete output.code;
        delete output.codeName;
    }
    return output;
}
/**
 * An error thrown when the server reports a writeConcernError
 * @public
 * @category Error
 */
class MongoWriteConcernError extends MongoError {
    constructor(message, result) {
        super(message);
        this.name = 'MongoWriteConcernError';
        if (result && Array.isArray(result.errorLabels)) {
            this[kErrorLabels] = new Set(result.errorLabels);
        }
        if (result != null) {
            this.result = makeWriteConcernResultObject(result);
        }
    }
}
exports.MongoWriteConcernError = MongoWriteConcernError;
// see: https://github.com/mongodb/specifications/blob/master/source/retryable-writes/retryable-writes.rst#terms
const RETRYABLE_ERROR_CODES = new Set([
    exports.MONGODB_ERROR_CODES.HostUnreachable,
    exports.MONGODB_ERROR_CODES.HostNotFound,
    exports.MONGODB_ERROR_CODES.NetworkTimeout,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.SocketException,
    exports.MONGODB_ERROR_CODES.NotMaster,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotMasterNoSlaveOk,
    exports.MONGODB_ERROR_CODES.NotMasterOrSecondary
]);
const RETRYABLE_WRITE_ERROR_CODES = new Set([
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotMaster,
    exports.MONGODB_ERROR_CODES.NotMasterNoSlaveOk,
    exports.MONGODB_ERROR_CODES.NotMasterOrSecondary,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.HostNotFound,
    exports.MONGODB_ERROR_CODES.HostUnreachable,
    exports.MONGODB_ERROR_CODES.NetworkTimeout,
    exports.MONGODB_ERROR_CODES.SocketException,
    exports.MONGODB_ERROR_CODES.ExceededTimeLimit
]);
function isRetryableWriteError(error) {
    var _a, _b, _c, _d;
    if (error instanceof MongoWriteConcernError) {
        return RETRYABLE_WRITE_ERROR_CODES.has((_c = (_b = (_a = error.result) === null || _a === void 0 ? void 0 : _a.code) !== null && _b !== void 0 ? _b : error.code) !== null && _c !== void 0 ? _c : 0);
    }
    return RETRYABLE_WRITE_ERROR_CODES.has((_d = error.code) !== null && _d !== void 0 ? _d : 0);
}
exports.isRetryableWriteError = isRetryableWriteError;
/** Determines whether an error is something the driver should attempt to retry */
function isRetryableError(error) {
    return (
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    RETRYABLE_ERROR_CODES.has(error.code) ||
        error instanceof MongoNetworkError ||
        !!error.message.match(/not master/) ||
        !!error.message.match(/node is recovering/));
}
exports.isRetryableError = isRetryableError;
const SDAM_RECOVERING_CODES = new Set([
    exports.MONGODB_ERROR_CODES.ShutdownInProgress,
    exports.MONGODB_ERROR_CODES.PrimarySteppedDown,
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.InterruptedDueToReplStateChange,
    exports.MONGODB_ERROR_CODES.NotMasterOrSecondary
]);
const SDAM_NOTMASTER_CODES = new Set([
    exports.MONGODB_ERROR_CODES.NotMaster,
    exports.MONGODB_ERROR_CODES.NotMasterNoSlaveOk,
    exports.MONGODB_ERROR_CODES.LegacyNotPrimary
]);
const SDAM_NODE_SHUTTING_DOWN_ERROR_CODES = new Set([
    exports.MONGODB_ERROR_CODES.InterruptedAtShutdown,
    exports.MONGODB_ERROR_CODES.ShutdownInProgress
]);
function isRecoveringError(err) {
    if (typeof err.code !== 'undefined') {
        // If any error code exists, we ignore the error.message
        return SDAM_RECOVERING_CODES.has(err.code);
    }
    return /not master or secondary/.test(err.message) || /node is recovering/.test(err.message);
}
function isNotMasterError(err) {
    if (typeof err.code !== 'undefined') {
        // If any error code exists, we ignore the error.message
        return SDAM_NOTMASTER_CODES.has(err.code);
    }
    if (isRecoveringError(err)) {
        return false;
    }
    return /not master/.test(err.message);
}
function isNodeShuttingDownError(err) {
    return !!(err.code && SDAM_NODE_SHUTTING_DOWN_ERROR_CODES.has(err.code));
}
exports.isNodeShuttingDownError = isNodeShuttingDownError;
/**
 * Determines whether SDAM can recover from a given error. If it cannot
 * then the pool will be cleared, and server state will completely reset
 * locally.
 *
 * @see https://github.com/mongodb/specifications/blob/master/source/server-discovery-and-monitoring/server-discovery-and-monitoring.rst#not-master-and-node-is-recovering
 */
function isSDAMUnrecoverableError(error) {
    // NOTE: null check is here for a strictly pre-CMAP world, a timeout or
    //       close event are considered unrecoverable
    if (error instanceof MongoParseError || error == null) {
        return true;
    }
    if (typeof error.code !== 'undefined') {
        return isRecoveringError(error) || isNotMasterError(error);
    }
    if (isRecoveringError(error) || isNotMasterError(error)) {
        return true;
    }
    return false;
}
exports.isSDAMUnrecoverableError = isSDAMUnrecoverableError;
function isNetworkTimeoutError(err) {
    return !!(err instanceof MongoNetworkError && err.message.match(/timed out/));
}
exports.isNetworkTimeoutError = isNetworkTimeoutError;
// From spec@https://github.com/mongodb/specifications/blob/7a2e93d85935ee4b1046a8d2ad3514c657dc74fa/source/change-streams/change-streams.rst#resumable-error:
//
// An error is considered resumable if it meets any of the following criteria:
// - any error encountered which is not a server error (e.g. a timeout error or network error)
// - any server error response from a getMore command excluding those containing the error label
//   NonRetryableChangeStreamError and those containing the following error codes:
//   - Interrupted: 11601
//   - CappedPositionLost: 136
//   - CursorKilled: 237
//
// An error on an aggregate command is not a resumable error. Only errors on a getMore command may be considered resumable errors.
function isResumableError(error, wireVersion) {
    if (error instanceof MongoNetworkError) {
        return true;
    }
    if (typeof wireVersion !== 'undefined' && wireVersion >= 9) {
        // DRIVERS-1308: For 4.4 drivers running against 4.4 servers, drivers will add a special case to treat the CursorNotFound error code as resumable
        if (error && error instanceof MongoError && error.code === 43) {
            return true;
        }
        return error instanceof MongoError && error.hasErrorLabel('ResumableChangeStreamError');
    }
    if (error && typeof error.code === 'number') {
        return exports.GET_MORE_RESUMABLE_CODES.has(error.code);
    }
    return false;
}
exports.isResumableError = isResumableError;
//# sourceMappingURL=error.js.map