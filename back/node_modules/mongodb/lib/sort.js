"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatSort = void 0;
/** @internal */
function prepareDirection(direction = 1) {
    const value = ('' + direction).toLowerCase();
    if (isMeta(direction))
        return direction;
    switch (value) {
        case 'ascending':
        case 'asc':
        case '1':
            return 1;
        case 'descending':
        case 'desc':
        case '-1':
            return -1;
        default:
            throw new Error(`Invalid sort direction: ${JSON.stringify(direction)}`);
    }
}
/** @internal */
function isMeta(t) {
    return typeof t === 'object' && t !== null && '$meta' in t && typeof t.$meta === 'string';
}
/** @internal */
function isPair(t) {
    if (Array.isArray(t) && t.length === 2) {
        try {
            prepareDirection(t[1]);
            return true;
        }
        catch (e) {
            return false;
        }
    }
    return false;
}
/** @internal */
function pairToObject(v) {
    return { [v[0]]: prepareDirection(v[1]) };
}
/** @internal */
function isDeep(t) {
    return Array.isArray(t) && Array.isArray(t[0]);
}
/** @internal */
function deepToObject(t) {
    const sortObject = {};
    for (const [name, value] of t) {
        sortObject[name] = prepareDirection(value);
    }
    return sortObject;
}
/** @internal */
function stringsToObject(t) {
    const sortObject = {};
    for (const key of t) {
        sortObject[key] = 1;
    }
    return sortObject;
}
/** @internal */
function objectToObject(t) {
    const sortObject = {};
    for (const key in t) {
        sortObject[key] = prepareDirection(t[key]);
    }
    return sortObject;
}
/** converts a Sort type into a type that is valid for the server (SortForCmd) */
function formatSort(sort, direction) {
    if (sort == null)
        return undefined;
    if (Array.isArray(sort) && !sort.length)
        return undefined;
    if (typeof sort === 'object' && !Object.keys(sort).length)
        return undefined;
    if (typeof sort === 'string')
        return { [sort]: prepareDirection(direction) };
    if (isPair(sort))
        return pairToObject(sort);
    if (isDeep(sort))
        return deepToObject(sort);
    if (Array.isArray(sort))
        return stringsToObject(sort);
    if (typeof sort === 'object')
        return objectToObject(sort);
    throw new Error(`Invalid sort format: ${JSON.stringify(sort)}`);
}
exports.formatSort = formatSort;
//# sourceMappingURL=sort.js.map