"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FindOneAndUpdateOperation = exports.FindOneAndReplaceOperation = exports.FindOneAndDeleteOperation = exports.FindAndModifyOperation = void 0;
const read_preference_1 = require("../read_preference");
const utils_1 = require("../utils");
const error_1 = require("../error");
const command_1 = require("./command");
const operation_1 = require("./operation");
const sort_1 = require("../sort");
/** @internal */
class FindAndModifyOperation extends command_1.CommandOperation {
    constructor(collection, query, sort, doc, options) {
        super(collection, options);
        this.options = options !== null && options !== void 0 ? options : {};
        // force primary read preference
        this.readPreference = read_preference_1.ReadPreference.primary;
        this.collection = collection;
        this.query = query;
        this.sort = sort;
        this.doc = doc;
    }
    execute(server, session, callback) {
        var _a;
        const coll = this.collection;
        const query = this.query;
        const sort = sort_1.formatSort(this.sort);
        const doc = this.doc;
        let options = { ...this.options, ...this.bsonOptions };
        // Create findAndModify command object
        const cmd = {
            findAndModify: coll.collectionName,
            query: query
        };
        if (sort) {
            cmd.sort = sort;
        }
        cmd.new = options.new ? true : false;
        cmd.remove = options.remove ? true : false;
        cmd.upsert = options.upsert ? true : false;
        const projection = options.projection || options.fields;
        if (projection) {
            cmd.fields = projection;
        }
        if (options.arrayFilters) {
            cmd.arrayFilters = options.arrayFilters;
        }
        if (doc && !options.remove) {
            cmd.update = doc;
        }
        if (options.maxTimeMS) {
            cmd.maxTimeMS = options.maxTimeMS;
        }
        // No check on the documents
        options.checkKeys = false;
        // Final options for retryable writes
        options = utils_1.applyRetryableWrites(options, coll.s.db);
        // Decorate the findAndModify command with the write Concern
        if (options.writeConcern) {
            cmd.writeConcern = options.writeConcern;
        }
        // Have we specified bypassDocumentValidation
        if (options.bypassDocumentValidation === true) {
            cmd.bypassDocumentValidation = options.bypassDocumentValidation;
        }
        // Have we specified collation
        try {
            utils_1.decorateWithCollation(cmd, coll, options);
        }
        catch (err) {
            return callback(err);
        }
        if (options.hint) {
            // TODO: once this method becomes a CommandOperation we will have the server
            // in place to check.
            const unacknowledgedWrite = ((_a = this.writeConcern) === null || _a === void 0 ? void 0 : _a.w) === 0;
            if (unacknowledgedWrite || utils_1.maxWireVersion(server) < 8) {
                callback(new error_1.MongoError('The current topology does not support a hint on findAndModify commands'));
                return;
            }
            cmd.hint = options.hint;
        }
        if (this.explain && utils_1.maxWireVersion(server) < 4) {
            callback(new error_1.MongoError(`server ${server.name} does not support explain on findAndModify`));
            return;
        }
        // Execute the command
        super.executeCommand(server, session, cmd, (err, result) => {
            if (err)
                return callback(err);
            return callback(undefined, result);
        });
    }
}
exports.FindAndModifyOperation = FindAndModifyOperation;
/** @internal */
class FindOneAndDeleteOperation extends FindAndModifyOperation {
    constructor(collection, filter, options) {
        // Final options
        const finalOptions = Object.assign({}, options);
        finalOptions.fields = options.projection;
        finalOptions.remove = true;
        // Basic validation
        if (filter == null || typeof filter !== 'object') {
            throw new TypeError('Filter parameter must be an object');
        }
        super(collection, filter, finalOptions.sort, undefined, finalOptions);
    }
}
exports.FindOneAndDeleteOperation = FindOneAndDeleteOperation;
/** @internal */
class FindOneAndReplaceOperation extends FindAndModifyOperation {
    constructor(collection, filter, replacement, options) {
        // Final options
        const finalOptions = Object.assign({}, options);
        finalOptions.fields = options.projection;
        finalOptions.update = true;
        finalOptions.new = options.returnOriginal !== void 0 ? !options.returnOriginal : false;
        finalOptions.upsert = options.upsert !== void 0 ? !!options.upsert : false;
        if (filter == null || typeof filter !== 'object') {
            throw new TypeError('Filter parameter must be an object');
        }
        if (replacement == null || typeof replacement !== 'object') {
            throw new TypeError('Replacement parameter must be an object');
        }
        if (utils_1.hasAtomicOperators(replacement)) {
            throw new TypeError('Replacement document must not contain atomic operators');
        }
        super(collection, filter, finalOptions.sort, replacement, finalOptions);
    }
}
exports.FindOneAndReplaceOperation = FindOneAndReplaceOperation;
/** @internal */
class FindOneAndUpdateOperation extends FindAndModifyOperation {
    constructor(collection, filter, update, options) {
        // Final options
        const finalOptions = Object.assign({}, options);
        finalOptions.fields = options.projection;
        finalOptions.update = true;
        finalOptions.new =
            typeof options.returnOriginal === 'boolean' ? !options.returnOriginal : false;
        finalOptions.upsert = typeof options.upsert === 'boolean' ? options.upsert : false;
        if (filter == null || typeof filter !== 'object') {
            throw new TypeError('Filter parameter must be an object');
        }
        if (update == null || typeof update !== 'object') {
            throw new TypeError('Update parameter must be an object');
        }
        if (!utils_1.hasAtomicOperators(update)) {
            throw new TypeError('Update document requires atomic operators');
        }
        super(collection, filter, finalOptions.sort, update, finalOptions);
    }
}
exports.FindOneAndUpdateOperation = FindOneAndUpdateOperation;
operation_1.defineAspects(FindAndModifyOperation, [
    operation_1.Aspect.WRITE_OPERATION,
    operation_1.Aspect.RETRYABLE,
    operation_1.Aspect.EXPLAINABLE
]);
//# sourceMappingURL=find_and_modify.js.map