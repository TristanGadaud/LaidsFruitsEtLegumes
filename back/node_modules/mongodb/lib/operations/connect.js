"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAutoEncrypter = exports.connect = void 0;
const error_1 = require("../error");
const topology_1 = require("../sdam/topology");
const connection_string_1 = require("../connection_string");
const connection_pool_1 = require("../cmap/connection_pool");
const BSON = require("../bson");
const connection_1 = require("../cmap/connection");
const server_1 = require("../sdam/server");
function connect(mongoClient, options, callback) {
    if (!callback) {
        throw new Error('no callback function provided');
    }
    // If a connection already been established, we can terminate early
    if (mongoClient.topology && mongoClient.topology.isConnected()) {
        return callback(undefined, mongoClient);
    }
    const logger = mongoClient.logger;
    const connectCallback = err => {
        const warningMessage = 'seed list contains no mongos proxies, replicaset connections requires ' +
            'the parameter replicaSet to be supplied in the URI or options object, ' +
            'mongodb://server:port/db?replicaSet=name';
        if (err && err.message === 'no mongos proxies found in seed list') {
            if (logger.isWarn()) {
                logger.warn(warningMessage);
            }
            // Return a more specific error message for MongoClient.connect
            return callback(new error_1.MongoError(warningMessage));
        }
        callback(err, mongoClient);
    };
    if (typeof options.srvHost === 'string') {
        return connection_string_1.resolveSRVRecord(options, (err, hosts) => {
            if (err || !hosts)
                return callback(err);
            for (const [index, host] of hosts.entries()) {
                options.hosts[index] = host;
            }
            return createTopology(mongoClient, options, connectCallback);
        });
    }
    return createTopology(mongoClient, options, connectCallback);
}
exports.connect = connect;
function createListener(mongoClient, event) {
    const eventSet = new Set(['all', 'fullsetup', 'open', 'reconnect']);
    return (v1, v2) => {
        if (eventSet.has(event)) {
            return mongoClient.emit(event, mongoClient);
        }
        return mongoClient.emit(event, v1, v2);
    };
}
/**
 * If AutoEncryption is requested, handles the optional dependency logic and passing through options
 * returns undefined if CSFLE is not enabled.
 * @throws if optional 'mongodb-client-encryption' dependency missing
 */
function createAutoEncrypter(client, options) {
    if (!options.autoEncryption) {
        return;
    }
    try {
        require.resolve('mongodb-client-encryption');
    }
    catch (err) {
        throw new error_1.MongoError('Auto-encryption requested, but the module is not installed. ' +
            'Please add `mongodb-client-encryption` as a dependency of your project');
    }
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const mongodbClientEncryption = require('mongodb-client-encryption');
    if (typeof mongodbClientEncryption.extension !== 'function') {
        throw new error_1.MongoError('loaded version of `mongodb-client-encryption` does not have property `extension`. ' +
            'Please make sure you are loading the correct version of `mongodb-client-encryption`');
    }
    const { AutoEncrypter: AutoEncrypterClass } = mongodbClientEncryption.extension(
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    require('../../lib/index'));
    const mongoCryptOptions = Object.assign({ bson: BSON }, options.autoEncryption);
    return new AutoEncrypterClass(client, mongoCryptOptions);
}
exports.createAutoEncrypter = createAutoEncrypter;
function createTopology(mongoClient, options, callback) {
    // Create the topology
    const topology = new topology_1.Topology(options.hosts, options);
    // Events can be emitted before initialization is complete so we have to
    // save the reference to the topology on the client ASAP if the event handlers need to access it
    mongoClient.topology = topology;
    // Add listeners
    topology.on('error', createListener(mongoClient, 'error'));
    topology.on('timeout', createListener(mongoClient, 'timeout'));
    topology.on('close', createListener(mongoClient, 'close'));
    topology.once('open', createListener(mongoClient, 'open'));
    // Propagate the events to the client
    relayEvents(mongoClient, topology);
    // initialize CSFLE if requested
    if (mongoClient.autoEncrypter) {
        mongoClient.autoEncrypter.init(err => {
            if (err) {
                callback(err);
                return;
            }
            topology.connect(options, err => {
                if (err) {
                    topology.close({ force: true });
                    callback(err);
                    return;
                }
                callback(undefined, topology);
            });
        });
        return;
    }
    // otherwise connect normally
    topology.connect(options, err => {
        if (err) {
            topology.close({ force: true });
            return callback(err);
        }
        callback(undefined, topology);
        return;
    });
}
function relayEvents(mongoClient, topology) {
    const serverOrCommandEvents = [
        // APM
        connection_1.Connection.COMMAND_STARTED,
        connection_1.Connection.COMMAND_SUCCEEDED,
        connection_1.Connection.COMMAND_FAILED,
        // SDAM
        topology_1.Topology.SERVER_OPENING,
        topology_1.Topology.SERVER_CLOSED,
        topology_1.Topology.SERVER_DESCRIPTION_CHANGED,
        server_1.Server.SERVER_HEARTBEAT_STARTED,
        server_1.Server.SERVER_HEARTBEAT_SUCCEEDED,
        server_1.Server.SERVER_HEARTBEAT_FAILED,
        topology_1.Topology.TOPOLOGY_OPENING,
        topology_1.Topology.TOPOLOGY_CLOSED,
        topology_1.Topology.TOPOLOGY_DESCRIPTION_CHANGED,
        ...connection_pool_1.CMAP_EVENT_NAMES
    ];
    for (const event of serverOrCommandEvents) {
        topology.on(event, (object1, object2) => {
            mongoClient.emit(event, object1, object2);
        });
    }
}
//# sourceMappingURL=connect.js.map